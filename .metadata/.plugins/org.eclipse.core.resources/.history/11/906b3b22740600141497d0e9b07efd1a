package Functions;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

import com.Functions.Payload;
import com.Functions.Snapshot;

import FileManager.DirDistributor;
import Main.SrvMain;


public class SocketConnector extends Thread {

	private Socket socket;
	private ObjectInputStream ois;
	private ObjectOutputStream oos;
	private String authCode = null, getTime = null ;
	public SocketConnector(Socket socket) {
		this.socket = socket;
	}

	public SocketConnector(Socket socket, ObjectInputStream ois) {
		this.socket = socket;
		this.ois = ois;
	}

	@Override
	public void run() {
		//authCode , time check
		try {
			authCode = (String)ois.readObject();
			getTime = (String)ois.readObject();
			
			System.out.println("authCode and getTime :" +authCode +"//"+getTime);
		} catch (ClassNotFoundException e2) {
			// TODO Auto-generated catch block
			e2.printStackTrace();
		} catch (IOException e2) {
			// TODO Auto-generated catch block
			e2.printStackTrace();
		}

		
		while (true && socket.isConnected()) {
			try {
				// read payloads
				Payload pl = (Payload) ois.readObject();
				System.out.println("payload opcode : " + pl.getOpCode());
				if (pl.getOpCode() == -1) {
					System.out.println("client left on server");
					ois.close();
					socket.close();
					return;
				}
				
				switch (pl.getOpCode()) {
				case 0:
					System.out.println("Snapshot Info request");
					//authCode내의 Snapshot Info Read
					File f = new File(SrvMain.homeDir+authCode);
					Snapshot ss;
					
					if(f.exists()){
						System.out.println("기기정보 확인 완료, Snapshot 확인 ");
						
						//해당 기기에 등록된 Snapshot 정보들 
						File[] inDirFile = f.listFiles();
						
						for(int i = 0 ; i < inDirFile.length ; i++){
							
							System.out.println("fileName : "+inDirFile[i].getName());
							
						}
				
						// code 디렉토리가 존재 시 날짜 확인
						/*f = new File(SrvMain.homeDir+authCode+"/"+getTime);
						
						if(f.exists()){ // 해댕 날짜의 데이터가 존재하는지 확인
							
							
							
						}else{
							
							
							
						}*/
						ss = new Snapshot();
						
					}else{
						System.out.println("Snapshot 정보가 존재하지 않습니다.");
						
						ss = new Snapshot();
						return;
					}
					
					// snapshot object 전송
					
					oos.writeObject(ss); // snapshot 정보 전송
					
					break;
				case 1:
					int fileLength = Integer.parseInt(ois.readObject()
							.toString()); 
					//인증코드 읽고 디렉토리 확인 및 생성
					DirDistributor dd = new DirDistributor(authCode, getTime);
					
					// snapshotDir (스냅샷이 저장 될 디렉토리 세팅 )
					SrvMain.snapshotDir = dd.getImgPath()+"/" ;
					
					if(dd.IsFolderExist()){ // 스냅샷 존재시

					}else{ // 처음 전송되는 스냅 샷
						// 전송 될 폴더 생성
						dd.mkFolder();
					}
					
					if (fileLength != 0) {
						System.out.println(SrvMain.snapshotDir);
						FileReceiver fr = new FileReceiver(SrvMain.snapshotDir,
								socket, ois, fileLength);
						fr.ReceiveFile();
						
					} else {
						System.out.println("there is no file to receive");
						System.out.println("socket Closed");
						ois.close();
						socket.close();
					}
					return;
				case 2: // file download
					System.out
							.println("server'll send a bunch of files to client");
					// client �뿉 fileList �쟾�넚
					File homeDir = new File(SrvMain.snapshotDir);
					File[] fileList = homeDir.listFiles();
					int fileCnt = 0;

					System.out
					.println("client에 전송 할 파일 수 : " + fileList.length);

					while (fileList.length > fileCnt) {
						System.out.println(fileList[fileCnt].getName());
						fileCnt++;
					}
					
					fileCnt = 0;

					oos = new ObjectOutputStream(socket.getOutputStream());
					// op 2 - send file list
					oos.writeObject(fileList);

					while (fileList.length > fileCnt) {
						if (fileList[fileCnt].isFile()) {
							FileInputStream fis = new FileInputStream(
									fileList[fileCnt]); // �뙆�씪�쓣 �닚�꽌��濡� �씫�뼱�삩�떎

							System.out.println("蹂대궡�뒗 �뙆�씪 : "
									+ fileList[fileCnt].getPath());
							byte[] byteArr = new byte[1024];
							int readByte = 0;
							long fileSize = 0;

							while ((readByte = fis.read(byteArr)) > 0) {
								fileSize += readByte;
								socket.getOutputStream().write(byteArr, 0,
										readByte);
							}

							fileSize = 0;
							fis.close();
							fileCnt++;
						} else {
							fileCnt++;
						}
					}
					break;
				case 3:
					ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
					
					// read generated code from client
					
					// send Payload with snapshot Information as per the code
					
					break;
					
				case 4:
					
					break;
				}

			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (NumberFormatException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (ClassNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} finally{
				return;
			}
		}

		System.out.println("end to receive"); // �닔�떊醫낅즺

	}

}
